#define GROUP_SIZE 1024

#pragma kernel CSSetIndices
#pragma kernel CSCalcDistances

#pragma use_dxc metal vulkan

#include "GaussianSplatting.hlsl"

Texture2D _SplatPositions;
float4x4 _WorldToCameraMatrix;
RWStructuredBuffer<uint> _SplatSortDistances;
RWStructuredBuffer<uint> _SplatSortKeys;
uint _SplatCount;
uint _SplatCountPOT;

[numthreads(GROUP_SIZE,1,1)]
void CSSetIndices (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCountPOT)
        return;

    _SplatSortKeys[idx] = idx;
}


[numthreads(GROUP_SIZE,1,1)]
void CSCalcDistances (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCountPOT)
        return;

    if (idx >= _SplatCount)
    {
        // fill pad-to-next-POT portion with dummy data that will never get sorted into regular data place
        _SplatSortDistances[idx] = 0;
        return;
    }

    uint origIdx = _SplatSortKeys[idx];
    uint3 coord = SplatIndexToPixelIndex(origIdx);

    uint chunkIdx = origIdx / kChunkSize;
    SplatChunkInfo chunk = _SplatChunks[chunkIdx];

    float3 pos = LoadSplatPosTex(coord);
    pos = lerp(chunk.boundsMin.pos, chunk.boundsMax.pos, pos);

    pos = mul(_WorldToCameraMatrix, float4(pos.xyz * float3(1,1,-1), 1)).xyz;
    // make distance radix sort friendly from http://stereopsis.com/radix.html
    uint fu = asuint(pos.z);
    uint mask = -((int)(fu >> 31)) | 0x80000000;
    _SplatSortDistances[idx] = fu ^ mask;
}
